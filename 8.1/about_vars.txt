         передача в функцию использование числа
int a   : &a (взятие адреса)                 a (использование переменной)
int *b  : b (использование указателя, т.е. адреса - указание на другую переменную, сравнение, передача в функцию)
                                            *b (разыменование указателя)
int c[10]: c ИЛИ &c[0] (адрес нулевого элемента) c[i] (индекс, т.е. получение элемента как обычной переменной)

указатель - число, которое показывает смещение ячейки памяти.
Т.е. например переменная a лежит на 500м месте с начала программы (в памяти)
Если мы присвоим b = &a , то сам b - адрес переменной a, а *b - её значение (т.е. число)

Функция может принимать либо указатель, либо значение
Если указатель (адрес), то указатели - безо всего, переменные со взятием адреса (&)
Если значение (данные), то указатель разыменовывается (*), переменная - безо всего

func(int *pointer) - func(&a); func(b)
Значения используются как указатель: *pointer = 5;
func(int value) - func(a); func(*b)
Значения как переменные: value = 3;

func(int *array) - func(c); func(&c[0])
Массив ведёт себя как обычно: array[2] = 7
НО! sizeof не работает в функции (т.к. передаётся только указатель)

int arr[10] = {1, 2...} // на каком-то расстоянии от 0 (левой границы памяти) лежат числа, 10 штук. Имя массива - 
указатель на это расстояние
int *b;

b = &arr[0]; // нулевой элемент, по аналогии с b = &a
b = arr; // всё равно нулевой элемент

printf("%i %i", *b, arr[0]); // 1 1

1) Присваивать
b = &a
2) Сравнивать с NULL
if (file == NULL) // проверка, что файл открылся
3) Сравнивать указатели
a = &arr[0]
b = &arr[1]
//b > a
4) Прибавить число к указателю
a = &arr[0]
b = a + 1 // то же, что и b = &arr[1]
5) Разность указателей - сколько между ними элементов этого типа
a = &arr[0]
b = &arr[1]
b - a == 1 // т.к. между индексами лежит одно число

a[i] = i[a] : *(a + i)